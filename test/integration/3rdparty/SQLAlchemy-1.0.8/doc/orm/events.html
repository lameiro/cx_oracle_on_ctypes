<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    ORM Events
 &mdash;
    SQLAlchemy 1.0 Documentation

        </title>

        
            <!-- begin iterate through SQLA + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
            <!-- end iterate through SQLA + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.0 Documentation" href="../index.html" />
        <link rel="up" title="Events and Internals" href="extending.html" />
        <link rel="next" title="ORM Internals" href="internals.html" />
        <link rel="prev" title="Events and Internals" href="extending.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.0.8</span> | Release Date: July 22, 2015
    </div>

    <h1>SQLAlchemy 1.0 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.0 Documentation</a></h3>

            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <input type="text" name="q" size="12" /> <input type="submit" value="Search" />
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">Object Relational Tutorial</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">Mapper Configuration</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">Relationship Configuration</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">Loading Objects</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session.html">Using the Session</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extending.html">Events and Internals</a></span><ul>
<li class="selected"><span class="link-container first"><strong>ORM Events</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#attribute-events">Attribute Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#mapper-events">Mapper Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#instance-events">Instance Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#session-events">Session Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#query-events">Query Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#module-sqlalchemy.orm.instrumentation">Instrumentation Events</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="internals.html">ORM Internals</a></span></li>
<li><span class="link-container first"><a class="reference external" href="exceptions.html">ORM Exceptions</a></span></li>
<li><span class="link-container first"><a class="reference external" href="deprecated.html">Deprecated ORM Event Interfaces</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM Extensions</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORM Examples</a></span></li>
</ul>



        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="orm-events">
<span id="orm-event-toplevel"></span><h1>ORM Events<a class="headerlink" href="#orm-events" title="Permalink to this headline">¶</a></h1>
<p>The ORM includes a wide variety of hooks available for subscription.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.7: </span>The event supersedes the previous system of &#8220;extension&#8221; classes.</p>
</div>
<p>For an introduction to the event API, see <a class="reference internal" href="../core/event.html"><span>Events</span></a>.  Non-ORM events
such as those regarding connections and low-level statement execution are described in
<a class="reference internal" href="../core/events.html"><span>Core Events</span></a>.</p>
<div class="section" id="attribute-events">
<h2>Attribute Events<a class="headerlink" href="#attribute-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.AttributeEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">AttributeEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events for object attributes.</p>
<p>These are typically defined on the class-bound descriptor for the
target class.</p>
<p>e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="k">def</span> <span class="nf">my_append_listener</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot;received append event for target: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">target</span>

<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">collection</span><span class="p">,</span> <span class="s">&#39;append&#39;</span><span class="p">,</span> <span class="n">my_append_listener</span><span class="p">)</span></pre></div>
</div>
<p>Listeners have the option to return a possibly modified version
of the value, when the <code class="docutils literal"><span class="pre">retval=True</span></code> flag is passed
to <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">listen()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">validate_phone</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">oldvalue</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s">&quot;Strip non-numeric characters from a phone number&quot;</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">r&#39;(?![0-9])&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c"># setup listener on UserContact.phone attribute, instructing</span>
<span class="c"># it to use the return value</span>
<span class="n">listen</span><span class="p">(</span><span class="n">UserContact</span><span class="o">.</span><span class="n">phone</span><span class="p">,</span> <span class="s">&#39;set&#39;</span><span class="p">,</span> <span class="n">validate_phone</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></pre></div>
</div>
<p>A validation function like the above can also raise an exception
such as <code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> to halt the operation.</p>
<p>Several modifiers are available to the <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">listen()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.active_history"></span><strong>active_history=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.active_history">¶</a> &#8211; When True, indicates that the
&#8220;set&#8221; event would like to receive the &#8220;old&#8221; value being
replaced unconditionally, even if this requires firing off
database loads. Note that <code class="docutils literal"><span class="pre">active_history</span></code> can also be
set directly via <a class="reference internal" href="mapping_columns.html#sqlalchemy.orm.column_property" title="sqlalchemy.orm.column_property"><code class="xref py py-func docutils literal"><span class="pre">column_property()</span></code></a> and
<a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.propagate"></span><strong>propagate=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.propagate">¶</a> &#8211; When True, the listener function will
be established not just for the class attribute given, but
for attributes of the same name on all current subclasses
of that class, as well as all future subclasses of that
class, using an additional listener that listens for
instrumentation events.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.raw"></span><strong>raw=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.raw">¶</a> &#8211; When True, the &#8220;target&#8221; argument to the
event will be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> management
object, rather than the mapped instance itself.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.retval"></span><strong>retval=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.retval">¶</a> &#8211; when True, the user-defined event
listening must return the &#8220;value&#8221; argument from the
function.  This gives the listening function the opportunity
to change the value that is ultimately used for a &#8220;set&#8221;
or &#8220;append&#8221; event.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>target</em>, <em>value</em>, <em>initiator</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a collection append event.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s">&#39;append&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_append</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;append&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.append.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.append.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.append.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.append.params.value">¶</a> &#8211; the value being appended.  If this listener
is registered with <code class="docutils literal"><span class="pre">retval=True</span></code>, the listener
function must return this value, or a new value which
replaces it.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.append.params.initiator"></span><strong>initiator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.append.params.initiator">¶</a> &#8211; <p>An instance of <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a>
representing the initiation of the event.  May be modified
from its original value by backref handlers in order to control
chained event propagation.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>the <code class="docutils literal"><span class="pre">initiator</span></code> argument is now
passed as a <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a> object, and may be
modified by backref handlers within a chain of backref-linked
events.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">if the event was registered with <code class="docutils literal"><span class="pre">retval=True</span></code>,
the given value, or a new effective value, should be returned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.dispose_collection">
<code class="descname">dispose_collection</code><span class="sig-paren">(</span><em>target</em>, <em>collection</em>, <em>collection_adpater</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.dispose_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a &#8216;collection dispose&#8217; event.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s">&#39;dispose_collection&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_dispose_collection</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">collection_adpater</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;dispose_collection&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is triggered for a collection-based attribute when
a collection is replaced, that is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

<span class="n">u1</span><span class="o">.</span><span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">]</span>  <span class="c"># &lt;- old collection is disposed</span></pre></div>
</div>
<p>The mechanics of the event will typically include that the given
collection is empty, even if it stored objects while being replaced.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.0: </span>the <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection" title="sqlalchemy.orm.events.AttributeEvents.init_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.init_collection()</span></code></a>
and <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.dispose_collection" title="sqlalchemy.orm.events.AttributeEvents.dispose_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.dispose_collection()</span></code></a> events supersede
the <code class="xref py py-class docutils literal"><span class="pre">collection.linker</span></code> hook.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.init_collection">
<code class="descname">init_collection</code><span class="sig-paren">(</span><em>target</em>, <em>collection</em>, <em>collection_adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.init_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a &#8216;collection init&#8217; event.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s">&#39;init_collection&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_init_collection</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">collection_adapter</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;init_collection&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is triggered for a collection-based attribute, when
the initial &#8220;empty collection&#8221; is first generated for a blank
attribute, as well as for when the collection is replaced with
a new one, such as via a set event.</p>
<p>E.g., given that <code class="docutils literal"><span class="pre">User.addresses</span></code> is a relationship-based
collection, the event is triggered here:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>  <span class="c">#  &lt;- new collection</span></pre></div>
</div>
<p>and also during replace operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u1</span><span class="o">.</span><span class="n">addresess</span> <span class="o">=</span> <span class="p">[</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">]</span>  <span class="c">#  &lt;- new collection</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_collection.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection"></span><strong>collection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection">¶</a> &#8211; the new collection.  This will always be generated
from what was specified as
<a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.params.collection_class" title="sqlalchemy.orm.properties.RelationshipProperty"><code class="xref py py-paramref docutils literal"><span class="pre">RelationshipProperty.collection_class</span></code></a>, and will always
be empty.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection_adpater"></span><strong>collection_adpater</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection_adpater">¶</a> &#8211; the <a class="reference internal" href="collections.html#sqlalchemy.orm.collections.CollectionAdapter" title="sqlalchemy.orm.collections.CollectionAdapter"><code class="xref py py-class docutils literal"><span class="pre">CollectionAdapter</span></code></a> that will
mediate internal access to the collection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.0: </span>the <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection" title="sqlalchemy.orm.events.AttributeEvents.init_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.init_collection()</span></code></a>
and <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.dispose_collection" title="sqlalchemy.orm.events.AttributeEvents.dispose_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.dispose_collection()</span></code></a> events supersede
the <code class="xref py py-class docutils literal"><span class="pre">collection.linker</span></code> hook.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>target</em>, <em>value</em>, <em>initiator</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a collection remove event.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s">&#39;remove&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_remove</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;remove&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.remove.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.remove.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.remove.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.remove.params.value">¶</a> &#8211; the value being removed.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.remove.params.initiator"></span><strong>initiator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.remove.params.initiator">¶</a> &#8211; <p>An instance of <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a>
representing the initiation of the event.  May be modified
from its original value by backref handlers in order to control
chained event propagation.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>the <code class="docutils literal"><span class="pre">initiator</span></code> argument is now
passed as a <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a> object, and may be
modified by backref handlers within a chain of backref-linked
events.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is defined for this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>target</em>, <em>value</em>, <em>oldvalue</em>, <em>initiator</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a scalar set event.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s">&#39;set&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_set</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">oldvalue</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;set&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span>

<span class="c"># named argument style (new in 0.9)</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s">&#39;set&#39;</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_set</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;set&#39; event&quot;</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;target&#39;</span><span class="p">]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;value&#39;</span><span class="p">]</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.value">¶</a> &#8211; the value being set.  If this listener
is registered with <code class="docutils literal"><span class="pre">retval=True</span></code>, the listener
function must return this value, or a new value which
replaces it.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.oldvalue"></span><strong>oldvalue</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.oldvalue">¶</a> &#8211; the previous value being replaced.  This
may also be the symbol <code class="docutils literal"><span class="pre">NEVER_SET</span></code> or <code class="docutils literal"><span class="pre">NO_VALUE</span></code>.
If the listener is registered with <code class="docutils literal"><span class="pre">active_history=True</span></code>,
the previous value of the attribute will be loaded from
the database if the existing value is currently unloaded
or expired.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.initiator"></span><strong>initiator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.initiator">¶</a> &#8211; <p>An instance of <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a>
representing the initiation of the event.  May be modified
from its original value by backref handlers in order to control
chained event propagation.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>the <code class="docutils literal"><span class="pre">initiator</span></code> argument is now
passed as a <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a> object, and may be
modified by backref handlers within a chain of backref-linked
events.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">if the event was registered with <code class="docutils literal"><span class="pre">retval=True</span></code>,
the given value, or a new effective value, should be returned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mapper-events">
<h2>Mapper Events<a class="headerlink" href="#mapper-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.MapperEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">MapperEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events specific to mappings.</p>
<p>e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="k">def</span> <span class="nf">my_before_insert_listener</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="c"># execute a stored procedure upon INSERT,</span>
    <span class="c"># apply the value to the row to be inserted</span>
    <span class="n">target</span><span class="o">.</span><span class="n">calculated_value</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span>
                                <span class="s">&quot;select my_special_function(</span><span class="si">%d</span><span class="s">)&quot;</span>
                                <span class="o">%</span> <span class="n">target</span><span class="o">.</span><span class="n">special_number</span><span class="p">)</span>

<span class="c"># associate the listener function with SomeClass,</span>
<span class="c"># to execute during the &quot;before_insert&quot; hook</span>
<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span>
    <span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;before_insert&#39;</span><span class="p">,</span> <span class="n">my_before_insert_listener</span><span class="p">)</span></pre></div>
</div>
<p>Available targets include:</p>
<ul class="simple">
<li>mapped classes</li>
<li>unmapped superclasses of mapped or to-be-mapped classes
(using the <code class="docutils literal"><span class="pre">propagate=True</span></code> flag)</li>
<li><a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> objects</li>
<li>the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class itself and the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a>
function indicate listening for all mappers.</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.8.0: </span>mapper events can be associated with
unmapped superclasses of mapped classes.</p>
</div>
<p>Mapper events provide hooks into critical sections of the
mapper, including those related to object instrumentation,
object loading, and object persistence. In particular, the
persistence methods <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert" title="sqlalchemy.orm.events.MapperEvents.before_insert"><code class="xref py py-meth docutils literal"><span class="pre">before_insert()</span></code></a>,
and <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update" title="sqlalchemy.orm.events.MapperEvents.before_update"><code class="xref py py-meth docutils literal"><span class="pre">before_update()</span></code></a> are popular
places to augment the state being persisted - however, these
methods operate with several significant restrictions. The
user is encouraged to evaluate the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> and
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.after_flush()</span></code></a> methods as more
flexible and user-friendly hooks in which to apply
additional database state during a flush.</p>
<p>When using <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents" title="sqlalchemy.orm.events.MapperEvents"><code class="xref py py-class docutils literal"><span class="pre">MapperEvents</span></code></a>, several modifiers are
available to the <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">event.listen()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.params.propagate"></span><strong>propagate=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.params.propagate">¶</a> &#8211; When True, the event listener should
be applied to all inheriting mappers and/or the mappers of
inheriting classes, as well as any
mapper which is the target of this listener.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.params.raw"></span><strong>raw=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.params.raw">¶</a> &#8211; When True, the &#8220;target&#8221; argument passed
to applicable event listener functions will be the
instance&#8217;s <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> management
object, rather than the mapped instance itself.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.params.retval"></span><strong>retval=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.params.retval">¶</a> &#8211; <p>when True, the user-defined event function
must have a return value, the purpose of which is either to
control subsequent event propagation, or to otherwise alter
the operation in progress by the mapper.   Possible return
values are:</p>
<ul>
<li><code class="docutils literal"><span class="pre">sqlalchemy.orm.interfaces.EXT_CONTINUE</span></code> - continue event
processing normally.</li>
<li><code class="docutils literal"><span class="pre">sqlalchemy.orm.interfaces.EXT_STOP</span></code> - cancel all subsequent
event handlers in the chain.</li>
<li>other values - the return value specified by specific listeners.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_configured">
<code class="descname">after_configured</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after a series of mappers have been configured.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;after_configured&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_configured</span><span class="p">():</span>
    <span class="s">&quot;listen for the &#39;after_configured&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This corresponds to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> call, which
note is usually called automatically as mappings are first
used.</p>
<p>This event can <strong>only</strong> be applied to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class
or <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> function, and not to individual mappings or
mapped classes.  It is only invoked for all mappings as a whole:</p>
<div class="highlight-python"><div class="highlight"><pre>from sqlalchemy.orm import mapper

@event.listens_for(mapper, &quot;after_configured&quot;)
def go():
    # ...</pre></div>
</div>
<p>Theoretically this event is called once per
application, but is actually called any time new mappers
have been affected by a <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a>
call.   If new mappings are constructed after existing ones have
already been used, this event can be called again.  To ensure
that a particular event is only called once and no further, the
<code class="docutils literal"><span class="pre">once=True</span></code> argument (new in 0.9.4) can be applied:</p>
<div class="highlight-python"><div class="highlight"><pre>from sqlalchemy.orm import mapper

@event.listens_for(mapper, &quot;after_configured&quot;, once=True)
def go():
    # ...</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_delete">
<code class="descname">after_delete</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after a DELETE statement
has been emitted corresponding to that instance.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;after_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_delete</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_delete&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to emit additional SQL statements on
the given connection as well as to perform application
specific bookkeeping related to a deletion event.</p>
<p>The event is often called for a batch of objects of the
same class after their DELETE statements have been emitted at
once in a previous step.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Mapper-level flush events are designed to operate <strong>on attributes
local to the immediate object being handled
and via SQL operations with the given</strong> <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>
<strong>only.</strong> Handlers here should <strong>not</strong> make alterations to the
state of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> overall, and in general should not
affect any <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a> -mapped attributes, as
session cascade rules will not function properly, nor is it
always known if the related class has already been handled.
Operations that <strong>are not supported in mapper events</strong> include:</p>
<ul class="simple">
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a></li>
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a></li>
<li>Mapped collection append, add, remove, delete, discard, etc.</li>
<li>Mapped relationship attribute set/del events,
i.e. <code class="docutils literal"><span class="pre">someobject.related</span> <span class="pre">=</span> <span class="pre">someotherobject</span></code></li>
</ul>
<p>Operations which manipulate the state of the object
relative to other objects are better handled:</p>
<ul class="last simple">
<li>In the <code class="docutils literal"><span class="pre">__init__()</span></code> method of the mapped object itself,
or another method designed to establish some particular state.</li>
<li>In a <code class="docutils literal"><span class="pre">&#64;validates</span></code> handler, see <a class="reference internal" href="mapped_attributes.html#simple-validators"><span>Simple Validators</span></a></li>
<li>Within the  <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> event.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_delete.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_delete.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_delete.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_delete.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit DELETE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_delete.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_delete.params.target">¶</a> &#8211; the mapped instance being deleted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_insert">
<code class="descname">after_insert</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after an INSERT statement
is emitted corresponding to that instance.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;after_insert&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_insert</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_insert&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify in-Python-only
state on the instance after an INSERT occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>The event is often called for a batch of objects of the
same class after their INSERT statements have been
emitted at once in a previous step. In the extremely
rare case that this is not desirable, the
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be configured with <code class="docutils literal"><span class="pre">batch=False</span></code>,
which will cause batches of instances to be broken up
into individual (and more poorly performing)
event-&gt;persist-&gt;event steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Mapper-level flush events are designed to operate <strong>on attributes
local to the immediate object being handled
and via SQL operations with the given</strong>
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> <strong>only.</strong> Handlers here should <strong>not</strong> make
alterations to the state of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> overall, and in
general should not affect any <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a> -mapped
attributes, as session cascade rules will not function properly,
nor is it always known if the related class has already been
handled. Operations that <strong>are not supported in mapper
events</strong> include:</p>
<ul class="simple">
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a></li>
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a></li>
<li>Mapped collection append, add, remove, delete, discard, etc.</li>
<li>Mapped relationship attribute set/del events,
i.e. <code class="docutils literal"><span class="pre">someobject.related</span> <span class="pre">=</span> <span class="pre">someotherobject</span></code></li>
</ul>
<p>Operations which manipulate the state of the object
relative to other objects are better handled:</p>
<ul class="last simple">
<li>In the <code class="docutils literal"><span class="pre">__init__()</span></code> method of the mapped object itself,
or another method designed to establish some particular state.</li>
<li>In a <code class="docutils literal"><span class="pre">&#64;validates</span></code> handler, see <a class="reference internal" href="mapped_attributes.html#simple-validators"><span>Simple Validators</span></a></li>
<li>Within the  <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> event.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_insert.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_insert.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_insert.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_insert.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit INSERT statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_insert.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_insert.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_update">
<code class="descname">after_update</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after an UPDATE statement
is emitted corresponding to that instance.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;after_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_update</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_update&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify in-Python-only
state on the instance after an UPDATE occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>This method is called for all instances that are
marked as &#8220;dirty&#8221;, <em>even those which have no net changes
to their column-based attributes</em>, and for which
no UPDATE statement has proceeded. An object is marked
as dirty when any of its column-based attributes have a
&#8220;set attribute&#8221; operation called or when any of its
collections are modified. If, at update time, no
column-based attributes have any net changes, no UPDATE
statement will be issued. This means that an instance
being sent to <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update" title="sqlalchemy.orm.events.MapperEvents.after_update"><code class="xref py py-meth docutils literal"><span class="pre">after_update()</span></code></a> is
<em>not</em> a guarantee that an UPDATE statement has been
issued.</p>
<p>To detect if the column-based attributes on the object have net
changes, and therefore resulted in an UPDATE statement, use
<code class="docutils literal"><span class="pre">object_session(instance).is_modified(instance,</span>
<span class="pre">include_collections=False)</span></code>.</p>
<p>The event is often called for a batch of objects of the
same class after their UPDATE statements have been emitted at
once in a previous step. In the extremely rare case that
this is not desirable, the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be
configured with <code class="docutils literal"><span class="pre">batch=False</span></code>, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Mapper-level flush events are designed to operate <strong>on attributes
local to the immediate object being handled
and via SQL operations with the given</strong> <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>
<strong>only.</strong> Handlers here should <strong>not</strong> make alterations to the
state of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> overall, and in general should not
affect any <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a> -mapped attributes, as
session cascade rules will not function properly, nor is it
always known if the related class has already been handled.
Operations that <strong>are not supported in mapper events</strong> include:</p>
<ul class="simple">
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a></li>
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a></li>
<li>Mapped collection append, add, remove, delete, discard, etc.</li>
<li>Mapped relationship attribute set/del events,
i.e. <code class="docutils literal"><span class="pre">someobject.related</span> <span class="pre">=</span> <span class="pre">someotherobject</span></code></li>
</ul>
<p>Operations which manipulate the state of the object
relative to other objects are better handled:</p>
<ul class="last simple">
<li>In the <code class="docutils literal"><span class="pre">__init__()</span></code> method of the mapped object itself,
or another method designed to establish some particular state.</li>
<li>In a <code class="docutils literal"><span class="pre">&#64;validates</span></code> handler, see <a class="reference internal" href="mapped_attributes.html#simple-validators"><span>Simple Validators</span></a></li>
<li>Within the  <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> event.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_update.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_update.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit UPDATE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_update.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_configured">
<code class="descname">before_configured</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before a series of mappers have been configured.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;before_configured&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_configured</span><span class="p">():</span>
    <span class="s">&quot;listen for the &#39;before_configured&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This corresponds to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> call, which
note is usually called automatically as mappings are first
used.</p>
<p>This event can <strong>only</strong> be applied to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class
or <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> function, and not to individual mappings or
mapped classes.  It is only invoked for all mappings as a whole:</p>
<div class="highlight-python"><div class="highlight"><pre>from sqlalchemy.orm import mapper

@event.listens_for(mapper, &quot;before_configured&quot;)
def go():
    # ...</pre></div>
</div>
<p>Theoretically this event is called once per
application, but is actually called any time new mappers
are to be affected by a <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a>
call.   If new mappings are constructed after existing ones have
already been used, this event can be called again.  To ensure
that a particular event is only called once and no further, the
<code class="docutils literal"><span class="pre">once=True</span></code> argument (new in 0.9.4) can be applied:</p>
<div class="highlight-python"><div class="highlight"><pre>from sqlalchemy.orm import mapper

@event.listens_for(mapper, &quot;before_configured&quot;, once=True)
def go():
    # ...</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.3.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_delete">
<code class="descname">before_delete</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before a DELETE statement
is emitted corresponding to that instance.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;before_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_delete</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;before_delete&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to emit additional SQL statements on
the given connection as well as to perform application
specific bookkeeping related to a deletion event.</p>
<p>The event is often called for a batch of objects of the
same class before their DELETE statements are emitted at
once in a later step.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Mapper-level flush events are designed to operate <strong>on attributes
local to the immediate object being handled
and via SQL operations with the given</strong> <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>
<strong>only.</strong> Handlers here should <strong>not</strong> make alterations to the
state of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> overall, and in general should not
affect any <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a> -mapped attributes, as
session cascade rules will not function properly, nor is it
always known if the related class has already been handled.
Operations that <strong>are not supported in mapper events</strong> include:</p>
<ul class="simple">
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a></li>
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a></li>
<li>Mapped collection append, add, remove, delete, discard, etc.</li>
<li>Mapped relationship attribute set/del events,
i.e. <code class="docutils literal"><span class="pre">someobject.related</span> <span class="pre">=</span> <span class="pre">someotherobject</span></code></li>
</ul>
<p>Operations which manipulate the state of the object
relative to other objects are better handled:</p>
<ul class="last simple">
<li>In the <code class="docutils literal"><span class="pre">__init__()</span></code> method of the mapped object itself,
or another method designed to establish some particular state.</li>
<li>In a <code class="docutils literal"><span class="pre">&#64;validates</span></code> handler, see <a class="reference internal" href="mapped_attributes.html#simple-validators"><span>Simple Validators</span></a></li>
<li>Within the  <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> event.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_delete.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_delete.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_delete.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_delete.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit DELETE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_delete.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_delete.params.target">¶</a> &#8211; the mapped instance being deleted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_insert">
<code class="descname">before_insert</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before an INSERT statement
is emitted corresponding to that instance.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;before_insert&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_insert</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;before_insert&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify local, non-object related
attributes on the instance before an INSERT occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>The event is often called for a batch of objects of the
same class before their INSERT statements are emitted at
once in a later step. In the extremely rare case that
this is not desirable, the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be
configured with <code class="docutils literal"><span class="pre">batch=False</span></code>, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Mapper-level flush events are designed to operate <strong>on attributes
local to the immediate object being handled
and via SQL operations with the given</strong>
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> <strong>only.</strong> Handlers here should <strong>not</strong> make
alterations to the state of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> overall, and
in general should not affect any <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a> -mapped
attributes, as session cascade rules will not function properly,
nor is it always known if the related class has already been
handled. Operations that <strong>are not supported in mapper
events</strong> include:</p>
<ul class="simple">
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a></li>
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a></li>
<li>Mapped collection append, add, remove, delete, discard, etc.</li>
<li>Mapped relationship attribute set/del events,
i.e. <code class="docutils literal"><span class="pre">someobject.related</span> <span class="pre">=</span> <span class="pre">someotherobject</span></code></li>
</ul>
<p>Operations which manipulate the state of the object
relative to other objects are better handled:</p>
<ul class="last simple">
<li>In the <code class="docutils literal"><span class="pre">__init__()</span></code> method of the mapped object itself, or
another method designed to establish some particular state.</li>
<li>In a <code class="docutils literal"><span class="pre">&#64;validates</span></code> handler, see <a class="reference internal" href="mapped_attributes.html#simple-validators"><span>Simple Validators</span></a></li>
<li>Within the  <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> event.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_insert.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_insert.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit INSERT statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_insert.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_update">
<code class="descname">before_update</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before an UPDATE statement
is emitted corresponding to that instance.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;before_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_update</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;before_update&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify local, non-object related
attributes on the instance before an UPDATE occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>This method is called for all instances that are
marked as &#8220;dirty&#8221;, <em>even those which have no net changes
to their column-based attributes</em>. An object is marked
as dirty when any of its column-based attributes have a
&#8220;set attribute&#8221; operation called or when any of its
collections are modified. If, at update time, no
column-based attributes have any net changes, no UPDATE
statement will be issued. This means that an instance
being sent to <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update" title="sqlalchemy.orm.events.MapperEvents.before_update"><code class="xref py py-meth docutils literal"><span class="pre">before_update()</span></code></a> is
<em>not</em> a guarantee that an UPDATE statement will be
issued, although you can affect the outcome here by
modifying attributes so that a net change in value does
exist.</p>
<p>To detect if the column-based attributes on the object have net
changes, and will therefore generate an UPDATE statement, use
<code class="docutils literal"><span class="pre">object_session(instance).is_modified(instance,</span>
<span class="pre">include_collections=False)</span></code>.</p>
<p>The event is often called for a batch of objects of the
same class before their UPDATE statements are emitted at
once in a later step. In the extremely rare case that
this is not desirable, the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be
configured with <code class="docutils literal"><span class="pre">batch=False</span></code>, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Mapper-level flush events are designed to operate <strong>on attributes
local to the immediate object being handled
and via SQL operations with the given</strong> <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>
<strong>only.</strong> Handlers here should <strong>not</strong> make alterations to the
state of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> overall, and in general should not
affect any <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a> -mapped attributes, as
session cascade rules will not function properly, nor is it
always known if the related class has already been handled.
Operations that <strong>are not supported in mapper events</strong> include:</p>
<ul class="simple">
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a></li>
<li><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a></li>
<li>Mapped collection append, add, remove, delete, discard, etc.</li>
<li>Mapped relationship attribute set/del events,
i.e. <code class="docutils literal"><span class="pre">someobject.related</span> <span class="pre">=</span> <span class="pre">someotherobject</span></code></li>
</ul>
<p>Operations which manipulate the state of the object
relative to other objects are better handled:</p>
<ul class="last simple">
<li>In the <code class="docutils literal"><span class="pre">__init__()</span></code> method of the mapped object itself,
or another method designed to establish some particular state.</li>
<li>In a <code class="docutils literal"><span class="pre">&#64;validates</span></code> handler, see <a class="reference internal" href="mapped_attributes.html#simple-validators"><span>Simple Validators</span></a></li>
<li>Within the  <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> event.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_update.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_update.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit UPDATE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_update.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.instrument_class">
<code class="descname">instrument_class</code><span class="sig-paren">(</span><em>mapper</em>, <em>class_</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.instrument_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a class when the mapper is first constructed,
before instrumentation is applied to the mapped class.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;instrument_class&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_instrument_class</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;instrument_class&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is the earliest phase of mapper construction.
Most attributes of the mapper are not yet initialized.</p>
<p>This listener can either be applied to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a>
class overall, or to any un-mapped class which serves as a base
for classes that will be mapped (using the <code class="docutils literal"><span class="pre">propagate=True</span></code> flag):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="s">&quot;instrument_class&quot;</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_new_class</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">cls_</span><span class="p">):</span>
    <span class="s">&quot; ... &quot;</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.instrument_class.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.instrument_class.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.instrument_class.params.class_"></span><strong>class_</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.instrument_class.params.class_">¶</a> &#8211; the mapped class.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.mapper_configured">
<code class="descname">mapper_configured</code><span class="sig-paren">(</span><em>mapper</em>, <em>class_</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the mapper for the class is fully configured.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;mapper_configured&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_mapper_configured</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;mapper_configured&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is the latest phase of mapper construction, and
is invoked when the mapped classes are first used, so that
relationships between mappers can be resolved.   When the event is
called, the mapper should be in its final state.</p>
<p>While the configuration event normally occurs automatically,
it can be forced to occur ahead of time, in the case where the event
is needed before any actual mapper usage,  by using the
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">configure_mappers()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.mapper_configured.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.mapper_configured.params.class_"></span><strong>class_</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured.params.class_">¶</a> &#8211; the mapped class.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="instance-events">
<h2>Instance Events<a class="headerlink" href="#instance-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.InstanceEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">InstanceEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events specific to object lifecycle.</p>
<p>e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="k">def</span> <span class="nf">my_load_listener</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot;on load!&quot;</span>

<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;load&#39;</span><span class="p">,</span> <span class="n">my_load_listener</span><span class="p">)</span></pre></div>
</div>
<p>Available targets include:</p>
<ul class="simple">
<li>mapped classes</li>
<li>unmapped superclasses of mapped or to-be-mapped classes
(using the <code class="docutils literal"><span class="pre">propagate=True</span></code> flag)</li>
<li><a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> objects</li>
<li>the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class itself and the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a>
function indicate listening for all mappers.</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.8.0: </span>instance events can be associated with
unmapped superclasses of mapped classes.</p>
</div>
<p>Instance events are closely related to mapper events, but
are more specific to the instance and its instrumentation,
rather than its system of persistence.</p>
<p>When using <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents" title="sqlalchemy.orm.events.InstanceEvents"><code class="xref py py-class docutils literal"><span class="pre">InstanceEvents</span></code></a>, several modifiers are
available to the <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">event.listen()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.params.propagate"></span><strong>propagate=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.params.propagate">¶</a> &#8211; When True, the event listener should
be applied to all inheriting classes as well as the
class which is the target of this listener.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.params.raw"></span><strong>raw=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.params.raw">¶</a> &#8211; When True, the &#8220;target&#8221; argument passed
to applicable event listener functions will be the
instance&#8217;s <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> management
object, rather than the mapped instance itself.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.expire">
<code class="descname">expire</code><span class="sig-paren">(</span><em>target</em>, <em>attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.expire" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after its attributes or some subset
have been expired.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;expire&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_expire</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;expire&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>&#8216;keys&#8217; is a list of attribute names.  If None, the entire
state was expired.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.expire.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.expire.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.expire.params.attrs"></span><strong>attrs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.expire.params.attrs">¶</a> &#8211; sequence of attribute
names which were expired, or None if all attributes were
expired.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.first_init">
<code class="descname">first_init</code><span class="sig-paren">(</span><em>manager</em>, <em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.first_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the first instance of a particular mapping is called.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;first_init&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_first_init</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;first_init&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.init">
<code class="descname">init</code><span class="sig-paren">(</span><em>target</em>, <em>args</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an instance when its constructor is called.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;init&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_init</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;init&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This method is only called during a userland construction of
an object.  It is not called when an object is loaded from the
database.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.init_failure">
<code class="descname">init_failure</code><span class="sig-paren">(</span><em>target</em>, <em>args</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.init_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an instance when its constructor has been called,
and raised an exception.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;init_failure&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_init_failure</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;init_failure&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This method is only called during a userland construction of
an object.  It is not called when an object is loaded from the
database.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>target</em>, <em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after it has been created via
<code class="docutils literal"><span class="pre">__new__</span></code>, and after initial attribute population has
occurred.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;load&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_load</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;load&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This typically occurs when the instance is created based on
incoming result rows, and is only called once for that
instance&#8217;s lifetime.</p>
<p>Note that during a result-row load, this method is called upon
the first row received for this instance.  Note that some
attributes and collections may or may not be loaded or even
initialized, depending on what&#8217;s present in the result rows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.load.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.load.params.context"></span><strong>context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load.params.context">¶</a> &#8211; the <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> corresponding to the
current <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> in progress.  This argument may be
<code class="docutils literal"><span class="pre">None</span></code> if the load does not correspond to a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a>,
such as during <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.merge" title="sqlalchemy.orm.session.Session.merge"><code class="xref py py-meth docutils literal"><span class="pre">Session.merge()</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.pickle">
<code class="descname">pickle</code><span class="sig-paren">(</span><em>target</em>, <em>state_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance when its associated state is
being pickled.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;pickle&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_pickle</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;pickle&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.pickle.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.pickle.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.pickle.params.state_dict"></span><strong>state_dict</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.pickle.params.state_dict">¶</a> &#8211; the dictionary returned by
<code class="xref py py-class docutils literal"><span class="pre">InstanceState.__getstate__</span></code>, containing the state
to be pickled.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.refresh">
<code class="descname">refresh</code><span class="sig-paren">(</span><em>target</em>, <em>context</em>, <em>attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after one or more attributes have
been refreshed from a query.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;refresh&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_refresh</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;refresh&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh.params.context"></span><strong>context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh.params.context">¶</a> &#8211; the <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> corresponding to the
current <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> in progress.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh.params.attrs"></span><strong>attrs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh.params.attrs">¶</a> &#8211; sequence of attribute names which
were populated, or None if all column-mapped, non-deferred
attributes were populated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.refresh_flush">
<code class="descname">refresh_flush</code><span class="sig-paren">(</span><em>target</em>, <em>flush_context</em>, <em>attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after one or more attributes have
been refreshed within the persistence of the object.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;refresh_flush&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_refresh_flush</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;refresh_flush&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is the same as <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh" title="sqlalchemy.orm.events.InstanceEvents.refresh"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.refresh()</span></code></a> except
it is invoked within the unit of work flush process, and the values
here typically come from the process of handling an INSERT or
UPDATE, such as via the RETURNING clause or from Python-side default
values.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.5.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.attrs"></span><strong>attrs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.attrs">¶</a> &#8211; sequence of attribute names which
were populated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.unpickle">
<code class="descname">unpickle</code><span class="sig-paren">(</span><em>target</em>, <em>state_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.unpickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after its associated state has
been unpickled.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s">&#39;unpickle&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_unpickle</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;unpickle&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.unpickle.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.unpickle.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.unpickle.params.state_dict"></span><strong>state_dict</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.unpickle.params.state_dict">¶</a> &#8211; the dictionary sent to
<code class="xref py py-class docutils literal"><span class="pre">InstanceState.__setstate__</span></code>, containing the state
dictionary which was pickled.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="session-events">
<h2>Session Events<a class="headerlink" href="#session-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.SessionEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">SessionEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events specific to <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> lifecycle.</p>
<p>e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="k">def</span> <span class="nf">my_before_commit</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot;before commit!&quot;</span>

<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>

<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">Session</span><span class="p">,</span> <span class="s">&quot;before_commit&quot;</span><span class="p">,</span> <span class="n">my_before_commit</span><span class="p">)</span></pre></div>
</div>
<p>The <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">listen()</span></code></a> function will accept
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> objects as well as the return result
of <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.sessionmaker" title="sqlalchemy.orm.session.sessionmaker"><code class="xref py py-class docutils literal"><span class="pre">sessionmaker()</span></code></a> and <a class="reference internal" href="contextual.html#sqlalchemy.orm.scoping.scoped_session" title="sqlalchemy.orm.scoping.scoped_session"><code class="xref py py-class docutils literal"><span class="pre">scoped_session()</span></code></a>.</p>
<p>Additionally, it accepts the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> class which
will apply listeners to all <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> instances
globally.</p>
<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_attach">
<code class="descname">after_attach</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after an instance is attached to a session.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_attach&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_attach</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_attach&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This is called after an add, delete or merge.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As of 0.8, this event fires off <em>after</em> the item
has been fully associated with the session, which is
different than previous releases.  For event
handlers that require the object not yet
be part of session state (such as handlers which
may autoflush while the target object is not
yet complete) consider the
new <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="sqlalchemy.orm.events.SessionEvents.before_attach"><code class="xref py py-meth docutils literal"><span class="pre">before_attach()</span></code></a> event.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="sqlalchemy.orm.events.SessionEvents.before_attach"><code class="xref py py-meth docutils literal"><span class="pre">before_attach()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_begin">
<code class="descname">after_begin</code><span class="sig-paren">(</span><em>session</em>, <em>transaction</em>, <em>connection</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a transaction is begun on a connection</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_begin&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_begin</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_begin&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_begin.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_begin.params.transaction"></span><strong>transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin.params.transaction">¶</a> &#8211; The <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_begin.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin.params.connection">¶</a> &#8211; The <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object
which will be used for SQL statements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_bulk_delete">
<code class="descname">after_bulk_delete</code><span class="sig-paren">(</span><em>delete_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a bulk delete operation to the session.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style (arguments as of 0.9)</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_bulk_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_delete</span><span class="p">(</span><span class="n">delete_context</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_bulk_delete&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span>

<span class="c"># legacy calling style (pre-0.9)</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_bulk_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_delete</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">query_context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_bulk_delete&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9: </span>The <code class="docutils literal"><span class="pre">after_bulk_delete</span></code> event now accepts the 
arguments <code class="docutils literal"><span class="pre">delete_context</span></code>.
Listener functions which accept the previous argument 
signature(s) listed above will be automatically 
adapted to the new signature.</p>
</div>
<p>This is called as a result of the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.delete" title="sqlalchemy.orm.query.Query.delete"><code class="xref py py-meth docutils literal"><span class="pre">Query.delete()</span></code></a> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_bulk_delete.params.delete_context"></span><strong>delete_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_delete.params.delete_context">¶</a> &#8211; <p>a &#8220;delete context&#8221; object which contains
details about the update, including these attributes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">session</span></code> - the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> involved</li>
<li><code class="docutils literal"><span class="pre">query</span></code> -the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object that this update operation
was called upon.</li>
<li><code class="docutils literal"><span class="pre">context</span></code> The <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> object, corresponding
to the invocation of an ORM query.</li>
<li><code class="docutils literal"><span class="pre">result</span></code> the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal"><span class="pre">ResultProxy</span></code></a> returned as a result of the
bulk DELETE operation.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_bulk_update">
<code class="descname">after_bulk_update</code><span class="sig-paren">(</span><em>update_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a bulk update operation to the session.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style (arguments as of 0.9)</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_bulk_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_update</span><span class="p">(</span><span class="n">update_context</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_bulk_update&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span>

<span class="c"># legacy calling style (pre-0.9)</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_bulk_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_update</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">query_context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_bulk_update&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9: </span>The <code class="docutils literal"><span class="pre">after_bulk_update</span></code> event now accepts the 
arguments <code class="docutils literal"><span class="pre">update_context</span></code>.
Listener functions which accept the previous argument 
signature(s) listed above will be automatically 
adapted to the new signature.</p>
</div>
<p>This is called as a result of the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.update" title="sqlalchemy.orm.query.Query.update"><code class="xref py py-meth docutils literal"><span class="pre">Query.update()</span></code></a> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_bulk_update.params.update_context"></span><strong>update_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_update.params.update_context">¶</a> &#8211; <p>an &#8220;update context&#8221; object which contains
details about the update, including these attributes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">session</span></code> - the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> involved</li>
<li><code class="docutils literal"><span class="pre">query</span></code> -the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object that this update operation
was called upon.</li>
<li><code class="docutils literal"><span class="pre">context</span></code> The <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> object, corresponding
to the invocation of an ORM query.</li>
<li><code class="docutils literal"><span class="pre">result</span></code> the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal"><span class="pre">ResultProxy</span></code></a> returned as a result of the
bulk UPDATE operation.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_commit">
<code class="descname">after_commit</code><span class="sig-paren">(</span><em>session</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a commit has occurred.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_commit&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_commit</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_commit&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a> hook is <em>not</em> per-flush,
that is, the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> can emit SQL to the database
many times within the scope of a transaction.
For interception of these events, use the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a>,
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a>, or
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a>
events.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> is not in an active transaction
when the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a> event is invoked,
and therefore can not emit SQL.  To emit SQL corresponding to
every transaction, use the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a>
event.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_commit.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="sqlalchemy.orm.events.SessionEvents.after_begin"><code class="xref py py-meth docutils literal"><span class="pre">after_begin()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_flush">
<code class="descname">after_flush</code><span class="sig-paren">(</span><em>session</em>, <em>flush_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after flush has completed, but before commit has been
called.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_flush&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_flush</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_flush&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>Note that the session&#8217;s state is still in pre-flush, i.e. &#8216;new&#8217;,
&#8216;dirty&#8217;, and &#8216;deleted&#8217; lists still show pre-flush state as well
as the history settings on instance attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_flush_postexec">
<code class="descname">after_flush_postexec</code><span class="sig-paren">(</span><em>session</em>, <em>flush_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after flush has completed, and after the post-exec
state occurs.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_flush_postexec&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_flush_postexec</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_flush_postexec&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This will be when the &#8216;new&#8217;, &#8216;dirty&#8217;, and &#8216;deleted&#8217; lists are in
their final state.  An actual commit() may or may not have
occurred, depending on whether or not the flush started its own
transaction or participated in a larger transaction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_rollback">
<code class="descname">after_rollback</code><span class="sig-paren">(</span><em>session</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_rollback" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a real DBAPI rollback has occurred.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_rollback&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_rollback</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_rollback&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>Note that this event only fires when the <em>actual</em> rollback against
the database occurs - it does <em>not</em> fire each time the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.rollback" title="sqlalchemy.orm.session.Session.rollback"><code class="xref py py-meth docutils literal"><span class="pre">Session.rollback()</span></code></a> method is called, if the underlying
DBAPI transaction has already been rolled back.  In many
cases, the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> will not be in
an &#8220;active&#8221; state during this event, as the current
transaction is not valid.   To acquire a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>
which is active after the outermost rollback has proceeded,
use the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback" title="sqlalchemy.orm.events.SessionEvents.after_soft_rollback"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.after_soft_rollback()</span></code></a> event, checking the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.is_active" title="sqlalchemy.orm.session.Session.is_active"><code class="xref py py-attr docutils literal"><span class="pre">Session.is_active</span></code></a> flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_rollback.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_rollback.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_soft_rollback">
<code class="descname">after_soft_rollback</code><span class="sig-paren">(</span><em>session</em>, <em>previous_transaction</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after any rollback has occurred, including &#8220;soft&#8221;
rollbacks that don&#8217;t actually emit at the DBAPI level.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_soft_rollback&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_soft_rollback</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">previous_transaction</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_soft_rollback&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This corresponds to both nested and outer rollbacks, i.e.
the innermost rollback that calls the DBAPI&#8217;s
rollback() method, as well as the enclosing rollback
calls that only pop themselves from the transaction stack.</p>
<p>The given <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> can be used to invoke SQL and
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.query" title="sqlalchemy.orm.session.Session.query"><code class="xref py py-meth docutils literal"><span class="pre">Session.query()</span></code></a> operations after an outermost rollback
by first checking the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.is_active" title="sqlalchemy.orm.session.Session.is_active"><code class="xref py py-attr docutils literal"><span class="pre">Session.is_active</span></code></a> flag:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">Session</span><span class="p">,</span> <span class="s">&quot;after_soft_rollback&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">previous_transaction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">session</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;select * from some_table&quot;</span><span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.previous_transaction"></span><strong>previous_transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.previous_transaction">¶</a> &#8211; The <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>
transactional marker object which was just closed.   The current
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> for the given <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> is
available via the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.transaction" title="sqlalchemy.orm.session.Session.transaction"><code class="xref py py-attr docutils literal"><span class="pre">Session.transaction</span></code></a> attribute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.7.3.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_transaction_create">
<code class="descname">after_transaction_create</code><span class="sig-paren">(</span><em>session</em>, <em>transaction</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute when a new <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> is created.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_transaction_create&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_transaction_create</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_transaction_create&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event differs from <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="sqlalchemy.orm.events.SessionEvents.after_begin"><code class="xref py py-meth docutils literal"><span class="pre">after_begin()</span></code></a>
in that it occurs for each <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>
overall, as opposed to when transactions are begun
on individual database connections.  It is also invoked
for nested transactions and subtransactions, and is always
matched by a corresponding
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a> event
(assuming normal operation of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.session">¶</a> &#8211; the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.transaction"></span><strong>transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.transaction">¶</a> &#8211; the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.8.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_transaction_end">
<code class="descname">after_transaction_end</code><span class="sig-paren">(</span><em>session</em>, <em>transaction</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute when the span of a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> ends.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;after_transaction_end&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_transaction_end</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;after_transaction_end&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event differs from <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a>
in that it corresponds to all <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>
objects in use, including those for nested transactions
and subtransactions, and is always matched by a corresponding
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a> event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.session">¶</a> &#8211; the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.transaction"></span><strong>transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.transaction">¶</a> &#8211; the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.8.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.before_attach">
<code class="descname">before_attach</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute before an instance is attached to a session.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;before_attach&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_attach</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;before_attach&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This is called before an add, delete or merge causes
the object to be part of the session.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.8.: </span>Note that <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="sqlalchemy.orm.events.SessionEvents.after_attach"><code class="xref py py-meth docutils literal"><span class="pre">after_attach()</span></code></a>
now fires off after the item is part of the session.
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="sqlalchemy.orm.events.SessionEvents.before_attach"><code class="xref py py-meth docutils literal"><span class="pre">before_attach()</span></code></a> is provided for those cases where
the item should not yet be part of the session state.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="sqlalchemy.orm.events.SessionEvents.after_attach"><code class="xref py py-meth docutils literal"><span class="pre">after_attach()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.before_commit">
<code class="descname">before_commit</code><span class="sig-paren">(</span><em>session</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute before commit is called.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;before_commit&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_commit</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;before_commit&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a> hook is <em>not</em> per-flush,
that is, the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> can emit SQL to the database
many times within the scope of a transaction.
For interception of these events, use the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a>,
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a>, or
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a>
events.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_commit.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="sqlalchemy.orm.events.SessionEvents.after_begin"><code class="xref py py-meth docutils literal"><span class="pre">after_begin()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.before_flush">
<code class="descname">before_flush</code><span class="sig-paren">(</span><em>session</em>, <em>flush_context</em>, <em>instances</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute before flush process has started.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s">&#39;before_flush&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_flush</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">,</span> <span class="n">instances</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;before_flush&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_flush.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_flush.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_flush.params.instances"></span><strong>instances</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush.params.instances">¶</a> &#8211; Usually <code class="docutils literal"><span class="pre">None</span></code>, this is the collection of
objects which can be passed to the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.flush" title="sqlalchemy.orm.session.Session.flush"><code class="xref py py-meth docutils literal"><span class="pre">Session.flush()</span></code></a> method
(note this usage is deprecated).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="query-events">
<h2>Query Events<a class="headerlink" href="#query-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.QueryEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">QueryEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.QueryEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Represent events within the construction of a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object.</p>
<p>The events here are intended to be used with an as-yet-unreleased
inspection system for <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a>.   Some very basic operations
are possible now, however the inspection system is intended to allow
complex query manipulations to be automated.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.0.</span></p>
</div>
<dl class="method">
<dt id="sqlalchemy.orm.events.QueryEvents.before_compile">
<code class="descname">before_compile</code><span class="sig-paren">(</span><em>query</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.QueryEvents.before_compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object before it is composed into a
core <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal"><span class="pre">Select</span></code></a> object.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeQuery</span><span class="p">,</span> <span class="s">&#39;before_compile&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_compile</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;before_compile&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is intended to allow changes to the query given:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">Query</span><span class="p">,</span> <span class="s">&quot;before_compile&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">no_deleted</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">column_descriptions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="n">User</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="s">&#39;expr&#39;</span><span class="p">]</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entity</span><span class="o">.</span><span class="n">deleted</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">query</span></pre></div>
</div>
<p>The event should normally be listened with the <code class="docutils literal"><span class="pre">retval=True</span></code>
parameter set, so that the modified query may be returned.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-sqlalchemy.orm.instrumentation">
<span id="instrumentation-events"></span><h2>Instrumentation Events<a class="headerlink" href="#module-sqlalchemy.orm.instrumentation" title="Permalink to this headline">¶</a></h2>
<p>Defines SQLAlchemy&#8217;s system of class instrumentation.</p>
<p>This module is usually not directly visible to user applications, but
defines a large part of the ORM&#8217;s interactivity.</p>
<p>instrumentation.py deals with registration of end-user classes
for state tracking.   It interacts closely with state.py
and attributes.py which establish per-instance and per-class-attribute
instrumentation, respectively.</p>
<p>The class instrumentation system can be customized on a per-class
or global basis using the <a class="reference internal" href="extensions/instrumentation.html#module-sqlalchemy.ext.instrumentation" title="sqlalchemy.ext.instrumentation"><code class="xref py py-mod docutils literal"><span class="pre">sqlalchemy.ext.instrumentation</span></code></a>
module, which provides the means to build and specify
alternate instrumentation forms.</p>
<dl class="class">
<dt id="sqlalchemy.orm.events.InstrumentationEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">InstrumentationEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Events related to class instrumentation events.</p>
<p>The listeners here support being established against
any new style class, that is any object that is a subclass
of &#8216;type&#8217;.  Events will then be fired off for events
against that class.  If the &#8220;propagate=True&#8221; flag is passed
to event.listen(), the event will fire off for subclasses
of that class as well.</p>
<p>The Python <code class="docutils literal"><span class="pre">type</span></code> builtin is also accepted as a target,
which when used has the effect of events being emitted
for all classes.</p>
<p>Note the &#8220;propagate&#8221; flag here is defaulted to <code class="docutils literal"><span class="pre">True</span></code>,
unlike the other class level events where it defaults
to <code class="docutils literal"><span class="pre">False</span></code>.  This means that new subclasses will also
be the subject of these events, when a listener
is established on a superclass.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.8: </span>- events here will emit based
on comparing the incoming class to the type of class
passed to <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">event.listen()</span></code></a>.  Previously, the
event would fire for any class unconditionally regardless
of what class was sent for listening, despite
documentation which stated the contrary.</p>
</div>
<dl class="method">
<dt id="sqlalchemy.orm.events.InstrumentationEvents.attribute_instrument">
<code class="descname">attribute_instrument</code><span class="sig-paren">(</span><em>cls</em>, <em>key</em>, <em>inst</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents.attribute_instrument" title="Permalink to this definition">¶</a></dt>
<dd><div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeBaseClass</span><span class="p">,</span> <span class="s">&#39;attribute_instrument&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_attribute_instrument</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;attribute_instrument&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>Called when an attribute is instrumented.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstrumentationEvents.class_instrument">
<code class="descname">class_instrument</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents.class_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after the given class is instrumented.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeBaseClass</span><span class="p">,</span> <span class="s">&#39;class_instrument&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_class_instrument</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;class_instrument&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>To get at the <a class="reference internal" href="internals.html#sqlalchemy.orm.instrumentation.ClassManager" title="sqlalchemy.orm.instrumentation.ClassManager"><code class="xref py py-class docutils literal"><span class="pre">ClassManager</span></code></a>, use
<code class="xref py py-func docutils literal"><span class="pre">manager_of_class()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstrumentationEvents.class_uninstrument">
<code class="descname">class_uninstrument</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents.class_uninstrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before the given class is uninstrumented.</p>
<div class="event-signatures container">
<p>Example argument forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>

<span class="c"># standard decorator style</span>
<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">SomeBaseClass</span><span class="p">,</span> <span class="s">&#39;class_uninstrument&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_class_uninstrument</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="s">&quot;listen for the &#39;class_uninstrument&#39; event&quot;</span>

    <span class="c"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>To get at the <a class="reference internal" href="internals.html#sqlalchemy.orm.instrumentation.ClassManager" title="sqlalchemy.orm.instrumentation.ClassManager"><code class="xref py py-class docutils literal"><span class="pre">ClassManager</span></code></a>, use
<code class="xref py py-func docutils literal"><span class="pre">manager_of_class()</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links">
        Previous:
        <a href="extending.html" title="previous chapter">Events and Internals</a>
        Next:
        <a href="internals.html" title="next chapter">ORM Internals</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2015, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
</div>

</div>


        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.0.8',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


